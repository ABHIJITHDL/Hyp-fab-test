<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperledger Fabric Interface with Self-Signed Certificate</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/forge/0.10.0/forge.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2 {
            color: #333;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="text"], input[type="file"], textarea {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        #result, #certificateDisplay {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            white-space: pre-wrap;
            word-break: break-all;
        }
    </style>
</head>
<body>
<h1>Hyperledger Fabric Interface with Self-Signed Certificate</h1>

<h2>Step 1: Load Private Key</h2>
<div class="form-group">
    <label for="keyFile">Private Key File (PEM or DER format):</label>
    <input type="file" id="keyFile" accept=".pem,.der">
</div>
<button onclick="loadPrivateKey()">Load Private Key</button>
<div id="result"></div>

<h2>Step 2: Submit Transaction</h2>
<div class="form-group">
    <label for="channelName">Channel Name:</label>
    <input type="text" id="channelName" value="mychannel">
</div>
<div class="form-group">
    <label for="chaincodeName">Chaincode Name:</label>
    <input type="text" id="chaincodeName" value="ehr">
</div>
<div class="form-group">
    <label for="functionName">Function Name:</label>
    <input type="text" id="functionName" value="getAllEHRRecordsForPatient">
</div>
<div class="form-group">
    <label for="args">Arguments:</label>
    <input type="text" id="args" value="P01">
</div>
<button onclick="submitTransaction()">Submit Transaction</button>
<div id="result"></div>

<script>
    let privateKey;

    async function loadPrivateKey() {
    const keyFile = document.getElementById('keyFile').files[0];

    if (!keyFile) {
        alert('Please select a private key file.');
        return;
    }

    try {
        const keyText = await readFileAsText(keyFile);

        if (keyText.includes('-----BEGIN PRIVATE KEY-----')) {
            // It's a PEM format key
            console.log('Detected PEM format');
            const keyData = pemToArrayBuffer(keyText);
            await importPrivateKey(keyData, true); // True for PEM
        } else {
            // It must be a binary (DER) format key
            console.log('Detected binary DER format');
            const keyData = await readFileAsArrayBuffer(keyFile);
            await importPrivateKey(keyData, false); // False for DER
        }

        console.log('Private key loaded successfully');
        document.getElementById('result').innerText = 'Private key loaded successfully.';
    } catch (error) {
        console.error('Error:', error);
        document.getElementById('result').innerText = 'Failed to load private key. See console for details.';
    }
}

async function importPrivateKey(keyData, isPem) {
    if (isPem) {
        // If it's a PEM format, decode it first
        const keyDer = forge.util.decode64(forge.pem.decode(keyData)[0].body);
        keyData = str2ab(keyDer);
    }

    privateKey = await crypto.subtle.importKey(
        "pkcs8", // Format of the key
        keyData, // Key data (converted if PEM)
        { name: "ECDSA", namedCurve: "P-256" }, // EC key (P-256 curve)
        true, // Whether the key is extractable
        ["sign"] // Key usage
    );
}

async function importPrivateKey(keyData, isPem) {
    if (isPem) {
        console.log('Raw PEM content before processing:', keyData); // Log raw PEM content

        try {
            // Directly use the Base64-decoded key data, no need for forge.pem.decode()
            const keyDer = window.atob(keyData); // Decode Base64 directly
            keyData = str2ab(keyDer); // Convert to ArrayBuffer

        } catch (error) {
            console.error("Error during Base64 decoding:", error);
            throw new Error("Invalid Base64 content in PEM message.");
        }
    }

    try {
        privateKey = await crypto.subtle.importKey(
            "pkcs8", // Format of the key
            keyData, // Key data (converted from Base64)
            { name: "ECDSA", namedCurve: "P-256" }, // EC key (P-256 curve)
            true, // Whether the key is extractable
            ["sign"] // Key usage
        );
    } catch (importError) {
        console.error("Error importing key:", importError);
        throw new Error("Failed to import the private key.");
    }
}

function pemToArrayBuffer(pem) {
    const pemHeader = "-----BEGIN PRIVATE KEY-----";
    const pemFooter = "-----END PRIVATE KEY-----";

    // Clean the PEM content by removing headers, footers, newlines, and spaces
    const pemContents = pem
        .replace(pemHeader, '')
        .replace(pemFooter, '')
        .replace(/\r?\n|\r/g, '') // Remove all newlines
        .replace(/\s+/g, ''); // Remove all spaces

    console.log('Cleaned Base64 PEM content:', pemContents); // Log cleaned base64 content

    return pemContents; // Return the cleaned Base64 string for further processing
}

function str2ab(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}



function str2ab(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}

function readFileAsText(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => resolve(event.target.result);
        reader.onerror = (error) => reject(error);
        reader.readAsText(file); // Read as text to detect PEM
    });
}

function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => resolve(event.target.result);
        reader.onerror = (error) => reject(error);
        reader.readAsArrayBuffer(file); // Read as ArrayBuffer for DER
    });
}


    async function submitTransaction() {
        const channelName = document.getElementById('channelName').value;
        const chaincodeName = document.getElementById('chaincodeName').value;
        const functionName = document.getElementById('functionName').value;
        const args = document.getElementById('args').value;

        if (!privateKey) {
            alert('Please load a private key first.');
            return;
        }

        const transactionData = `${channelName}${chaincodeName}${functionName}${args}`;

        try {
            const md = forge.md.sha256.create();
            md.update(transactionData, 'utf8');
            const digest = new Uint8Array(forge.util.createBuffer(md.digest().bytes()).getBytes().split('').map(c => c.charCodeAt(0)));

            const signature = await crypto.subtle.sign({ name: "ECDSA", hash: { name: "SHA-256" } }, privateKey, digest);
            const signatureBytes = new Uint8Array(signature);
            const signatureBase64 = forge.util.encode64(String.fromCharCode.apply(null, signatureBytes));

            const dataToSend = { signature: signatureBase64, channelName, chaincodeName, functionName, args };
            const response = await fetch('/fabric/submit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(dataToSend)
            });

            const result = await response.text();
            document.getElementById('result').innerText = result;
        } catch (error) {
            console.error('Error:', error);
            document.getElementById('result').innerText = 'An error occurred. Please check the console for details.';
        }
    }
</script>
</body>
</html>
